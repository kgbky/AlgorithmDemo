### 基础知识

**时间复杂度（步数）**

    O计法指最坏的情况
    
	嵌套循环O(N*N) 意味着低效
    
	O只保留最高阶的N,且忽略常数。 O相同时，算法效率也有差别
    
	为最坏情况做好准备十分重要，但大部分时间我们面对的是平均情况

**空间复杂度（内存）**

	小内存设备或大量数据时
    
	省时又省内存的算法当然是最理想的，有些情况下只能二选一
    
	定义：当所处理的数据有 N 个元素时，该算法还需额外消耗多少内存空间。使用大 O 记法

**数据结构 和 算法 相互作用影响代码效率**

**访问数据结构中所有元素的过程，叫作遍历数据结构**

**递归：**

    写——首先考虑基准情形
    
    读——首先考虑基准情形  
    
    适合无法预估计算深度的问题


### 数据结构：

    数组： 
    读：1 O(1) 
    查：1——N 线性查找O(N) 
    插：1——N+1 
    删：1——N
	
	有序数组：
	插入慢，查找快(二分查找)
	
	List：
	读：O(N)
	查：O(N) 线性查找
	插：O(N)
	删：O(N)

	Set：
	读：1
	查：1——N 线性查找
	插：1——2N+1
	删：1——N
	
	Map：
	读:O(1)
	插:O(1)
	O(1)的读取和插入带来了无与伦比的性能优势
	
	栈 LIFO
	
	队列 FIFO 适合双向链表实现 效率O(1)
	
	二叉树:
	保持顺序，快速查找、插入和删除
	查：O(log N)
	插：O(log N)
	删：O(log N)
	
	图：
	适合处理关系型数据,社交网络和地图软件核心
	算法：广度优先搜索和深度优先搜索

### 算法：
	线性查找O(N)
	二分查找O(log N)
	冒泡排序O(N*N)
	选择排序O(N*N/2)
	插入排序O(N*N)	
	快速排序(递归排序)

效率：O(N*N)>O(N)>O(log N)>O(1)
